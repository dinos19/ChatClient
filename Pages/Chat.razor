@page "/chat/{CurrentChatroomAccountId}"
@using ChatClient.Infrastructure
@using ChatClient.Models
@using ChatClient.Services
@using ChatClient.Services.SignalR
@using ChatClient.Services.SignalR.Hubs
@using ChatClient.Services.ViewServices
@using ChatClient.Util
@using ChatClient.ViewModel
@using Microsoft.AspNetCore.SignalR.Client
@using Newtonsoft.Json
@using SqliteWasmHelper
@inject ChatViewModel viewModel
@implements IDisposable
@inject IJSRuntime JSRuntime;
@using Blazored.Modal.Services
@using System.Net.Http.Headers
@inject IModalService Modal

<h3>Chat</h3>

<script>
    function scrollToBottom(element) {
        element.scrollTop = element.scrollHeight;
    }
</script>

@if (viewModel.Messages == null)
{
    <p>Loading...</p>
}
else
{
    <div class="chat-wrapper">
        <div class="message-list" @ref="messageListDiv">
            @foreach (var message in viewModel.Messages)
            {
                <div class="message">
                    <div class="message-header">
                        <span class="message-sender">@message.FromAccount.Name</span>
                    </div>
                    <div class="message-content">
                        @if (message.Type == ChatMessageType.VIDEO)
                        {
                            <video @key="message.ChatMessageId" @ref="videoElements[message.ChatMessageId]" controls></video>

                            //LoadVideo(message); // Call this method appropriately

                        }
                        else
                        @message.Body
                    </div>
                </div>
            }
        </div>

        <div class="chat-input">
            <div class="action-buttons">

                <button onclick="document.getElementById('flpicker').click()">
                    <i class="fas fa-paperclip"></i>
                </button>
                <InputFile id="flpicker" OnChange="@OnInputFileChange" hidden multiple />

                <!-- Replace these with actual icons later -->
                <button @onclick="StartVideoRecording" title="Open video recorder">
                    <i class="fas fa-video"></i>

                </button>
                <button @onclick="StartAudioRecording" title="Record Audio">
                    <i class="fas fa-microphone"></i>
                </button>

            </div>
            <input type="text" @bind="viewModel.newMessageText" placeholder="Jot something down..." />
            <button @onclick="SendMessage" title="Send message">
                <i class="fas fa-paper-plane"></i>
            </button>
        </div>
    </div>
}
@code {
    [Parameter]
    public string CurrentChatroomAccountId { get; set; }
    private ElementReference messageListDiv;
    private Dictionary<int, ElementReference> videoElements = new();

    //private ElementReference videoElement;

    private async Task LoadVideo(ChatMessage message)
    {
        if (videoElements.TryGetValue(message.ChatMessageId, out var videoElement))
        {
            try
            {
                    var chatFile = await viewModel.chatHandler.GetFile(message);
                    if (chatFile is null) return;
                    message.ChatFile = chatFile;
                    await JSRuntime.InvokeVoidAsync("setVideoSource", videoElement, chatFile.FileContentArray, chatFile.UploadResultContentType ?? "video/mp4");
            }
            catch (Exception ex)
            {
                Console.Error.WriteLine($"Error loading video: {ex.Message}");
            }
        }
    }
    private IModalReference modalReference;

    private void StartVideoRecording()
    {
        var options = new ModalOptions
            {
                Position = ModalPosition.Middle, // This centers the modal in the viewport
                DisableBackgroundCancel = true,  // Optional: Disables closing the modal by clicking the background
                AnimationType = ModalAnimationType.FadeInOut // Optional: Adds an animation effect when showing the modal
            };
        ModalParameters parameters = new ModalParameters();
        parameters.Add("OnRecordingCompleted", EventCallback.Factory.Create<UploadResult>(this, HandleRecordingCompleted));

        modalReference = Modal.Show<VideoRecord>("", parameters, options);

    }
    private async Task HandleRecordingCompleted(UploadResult result)
    {

        await viewModel.SendMessageAsync(result, ChatMessageType.VIDEO);
        if (modalReference != null)
            modalReference = null;
    }
    private void StartAudioRecording()
    {
        var options = new ModalOptions
            {
                Position = ModalPosition.Middle,
                DisableBackgroundCancel = true,
                AnimationType = ModalAnimationType.FadeInOut
            };

        var modalReference = Modal.Show<VideoRecord>("", options);
    }

    private async Task ScrollToBottom()
    {
        await JSRuntime.InvokeVoidAsync("scrollToBottom", messageListDiv);
    }
    private List<string> fileNames = new();
    private List<UploadResult> uploadResults = new();

    private async Task OnInputFileChange(InputFileChangeEventArgs e)
    {
        using var content = new MultipartFormDataContent();

        foreach (var file in e.GetMultipleFiles())
        {

            //var resizedImage = await file.RequestImageFileAsync("image/png", 400, 400);

            var fileContent = new StreamContent(file.OpenReadStream(long.MaxValue));

            fileContent.Headers.ContentType = new MediaTypeHeaderValue(file.ContentType);

            fileNames.Add(file.Name);

            content.Add(
                content: fileContent,
                name: "\"files\"",
                fileName: file.Name);

            using (var stream = file.OpenReadStream(file.Size))
            {
                viewModel.fileSize = (int)stream.Length;
            }
        }
        var httpClient = new HttpClient();

        HttpResponseMessage response = await httpClient.PostAsync($"{Constants.ChatServerUrl}/File/UploadFile", content);

        var newUploadResults = await response.Content.ReadFromJsonAsync<List<UploadResult>>();

        if (newUploadResults is not null)
        {
            uploadResults = uploadResults.Concat(newUploadResults).ToList();
        }
        foreach (var uploadResult in newUploadResults)
        {
            await viewModel.SendMessageAsync(uploadResult, ChatMessageType.IMAGE);

        }
    }
    protected override async Task OnInitializedAsync()
    {
        //await UserStateService.InitializeAsync();
        viewModel.UserStateService.OnChange += StateHasChanged;
        viewModel.onMessageReceived += MessageReceived;

        await viewModel.chatHandler.SetUpSignalR();

        //await Task.Delay(500); // Give some time for everything to load
        await ScrollToBottom();

    }

    private async void MessageReceived(ChatMessage chatMessage)
    {
        try
        {

            StateHasChanged();
            if (chatMessage.Type == ChatMessageType.VIDEO)
            {
                await LoadVideo(chatMessage);
            }
            await ScrollToBottom();

        }
        catch (Exception ex)
        {

        }

    }
    protected override async Task OnParametersSetAsync()
    {
        await base.OnParametersSetAsync();
        var loadedMessages = await viewModel.ChatService.LoadSingleChatroom(viewModel.UserStateService.CurrentState.MyAccount.AccountId, int.Parse(CurrentChatroomAccountId));
        viewModel.Messages = loadedMessages;
        var hasUpdated = await viewModel.chatHandler.SendReadUpdates(viewModel.Messages);

        foreach (var chatMessage in loadedMessages)
        {
            if (chatMessage.Type == ChatMessageType.VIDEO)
            {
                await LoadVideo(chatMessage);
            }
        }

        StateHasChanged();

        await Task.Yield();
        await ScrollToBottom();

    }

    public void Dispose()
    {
        viewModel.UserStateService.OnChange -= StateHasChanged;
    }
    private async void SendMessage(MouseEventArgs e)
    {

        viewModel.chatHandler.SendMessage(viewModel.newMessageText);
        //await ScrollToBottom();

    }
}